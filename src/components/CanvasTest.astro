---

---

<input type="file" id="file-input" />
<canvas
    id="canvas-test"
    width="1200"
    height="800"
    style="border:1px solid #000000;"
>
</canvas>

<!-- Scripts go here -->
<script>
    import { MapNode, MapVertex, MapEdge, MapGraph } from "@components/MapGraph";

    const colors = [
        "#e6194b",
        "#3cb44b",
        "#ffe119",
        "#4363d8",
        "#f58231",
        "#911eb4",
        "#46f0f0",
        "#f032e6",
        "#bcf60c",
        "#fabebe",
        "#008080",
        "#e6beff",
        "#9a6324",
        "#800000",
        "#aaffc3",
        "#808000",
        "#000075",
        "#808080",
        "#000000",
    ];
    let inputElement: HTMLElement | null =
        document.getElementById("file-input")!;
    if (inputElement === null) throw new Error("File Input Element was null");

    let xmlDoc = null;
    let bounds = null;
    let nodes = [];
    let ways: HTMLElement[] = [];
    let wayValues = [
        "bus_stop",
        "crossing",
        "cycleway",
        "footway",
        "give_way",
        "living_street",
        "motorway",
        "motorway_junction",
        "motorway_link",
        "path",
        "pedestrian",
        "primary",
        "primary_link",
        "residential",
        "rest_area",
        "secondary",
        "service",
        "steps",
        "stop",
        "street_lamp",
        "tertiary",
        "track",
        "traffic_signals",
        "trailhead",
        "trunk",
        "turning_circle",
        "unclassified",
    ];

    const nodesMap: any = {};
    const mapGraph = new MapGraph();

    function getMinMaxCoords(nodes: Element[]) {
        let minlat = 1000;
        let maxlat = -1000;
        let minlon = 1000;
        let maxlon = -1000;
        Array.from(nodes).forEach((node) => {
            const id: string | null = node.getAttribute("id");
            let lat: string | number | null = node.getAttribute("lat");
            let lon: string | number | null = node.getAttribute("lon");

            if (id === null) {
                console.error(
                    `A <node> was found to be missing an id attribute in getMinMaxCoords(); Node was skipped`,
                );
                return;
            }
            if (lat === null || lon === null) {
                console.error(
                    `Missing lat or lon attribute for <node> with id ${id} in getMinMaxCoords(). Node was skipped`,
                );
                return;
            }

            lat = parseFloat(lat);
            lon = parseFloat(lon);

            minlat = Math.min(minlat, lat);
            maxlat = Math.max(maxlat, lat);
            minlon = Math.min(minlon, lon);
            maxlon = Math.max(maxlon, lon);
        });

        return [minlat, maxlat, minlon, maxlon];
    }

    function normalizeCoordinates(
        width: number,
        height: number,
        minlat: number,
        maxlat: number,
        minlon: number,
        maxlon: number,
        inputlat: number,
        inputlon: number,
    ) {
        const outputlat =
            height - height * ((inputlat - minlat) / (maxlat - minlat));
        const outputlon = width * ((inputlon - minlon) / (maxlon - minlon));
        return [outputlat, outputlon];
    }

    inputElement.addEventListener("change", handleFiles, false);
    function handleFiles(this: HTMLElement, ev: Event) {
        const target = ev.target as HTMLInputElement;
        const files = target.files!;
        let reader = new FileReader();
        reader.readAsText(files[0]);

        reader.onload = function () {
            const parser = new DOMParser();
            if (typeof reader.result !== "string")
                throw new Error(
                    "FileReader did not contain a string for it's results",
                );
            xmlDoc = parser.parseFromString(reader.result, "text/xml");

            bounds = xmlDoc.getElementsByTagName("bounds")[0];
            nodes = Array.from(xmlDoc.getElementsByTagName("node"));
            for (let value of wayValues) {
                const wayArray = Array.from(
                    xmlDoc.querySelectorAll(
                        `way tag[k = 'highway'][v = '${value}']`,
                    ),
                ).map((val) => val.parentElement!);
                ways = ways.concat(wayArray);
            }
            // ways = Array.from(
            //     xmlDoc.querySelectorAll(`way tag[k = 'highway']`),
            // ).map((val) => val.parentElement!);

            const canvas: HTMLCanvasElement = document.getElementById(
                "canvas-test",
            )! as HTMLCanvasElement;
            const context: CanvasRenderingContext2D = canvas.getContext("2d")!;
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            context.fillStyle = "#ffffff";
            context.beginPath();
            context.fillRect(0, 0, width, height);
            context.fillRect(0, 0, width, height);
            context.closePath();

            // Bounding min and max
            let minlat = parseFloat(bounds.getAttribute("minlat")!);
            let maxlat = parseFloat(bounds.getAttribute("maxlat")!);
            let minlon = parseFloat(bounds.getAttribute("minlon")!);
            let maxlon = parseFloat(bounds.getAttribute("maxlon")!);

            // [minlat, maxlat, minlon, maxlon] =
            // getMinMaxCoords(nodes);

            // GENERATE NODEMAP
            nodes.forEach((node) => {
                const id: string | null = node.getAttribute("id");
                let lat: string | number | null = node.getAttribute("lat");
                let lon: string | number | null = node.getAttribute("lon");

                if (id === null) {
                    console.error(
                        `A <node> was found to be missing an id attribute; Node was skipped`,
                    );
                    return;
                }
                if (lat === null || lon === null) {
                    console.error(
                        `Missing lat or lon attribute for <node> with id ${id}. Node was skipped`,
                    );
                    return;
                }

                lat = parseFloat(lat);
                lon = parseFloat(lon);
                const [ypos, xpos] = normalizeCoordinates(
                    width,
                    height,
                    minlat,
                    maxlat,
                    minlon,
                    maxlon,
                    lat,
                    lon,
                );

                nodesMap[id] = new MapNode(id, lat, lon, xpos, ypos);
            });

            // Count how many connections each node has to another from the xml file
            const countMap: any = {};
            ways.forEach((way) => {
                if (way === null) {
                    console.error(
                        `A <way> was found to be null; Way was skipped`,
                    );
                    return;
                }

                const nds = Array.from(way.getElementsByTagName("nd"));
                let prevNode: { id: string | number } | null = null;
                nds.forEach((nd) => {
                    const ref = nd.getAttribute("ref");
                    if (ref === null) {
                        console.error(
                            `A <way> was found to be missing a ref attribute; Way was skipped`,
                        );
                        return;
                    }

                    const currNode = nodesMap[ref];
                    if (prevNode !== null) {
                        countMap[prevNode.id] =
                            (countMap[prevNode.id] ?? 0) + 1;
                        countMap[currNode.id] =
                            (countMap[currNode.id] ?? 0) + 1;
                    }

                    prevNode = currNode;
                });
            });

            console.log(countMap);

            const vertices = [];
            // IDENTIFY VERTICIES (Nodes that have either 1 connection to another node or more than 2 connections (i.e., a junction))
            for (const id in countMap) {
                if (countMap[id] !== 2) {
                    const vertex = new MapVertex(nodesMap[id]);
                    nodesMap[id].setIsVertex(true);
                    vertices.push(vertex);
                }
            }
            mapGraph.addVertices(vertices);

            // IDENTIFY EDGES (Traverse the xml ways again. Edges are list of nodes between vertices, inclusively)
            let colorCount = 0;
            ways.forEach((way) => {
                if (way === null) {
                    console.error(
                        `A <way> was found to be null during edge generation; Way was skipped`,
                    );
                    return;
                }
                const nds = Array.from(way.getElementsByTagName("nd"));

                let edge: any[] = [];
                let prevNode: null = null;
                let startVertex: MapVertex | null = null;
                nds.forEach((nd, index, nds) => {
                    const id = nd.getAttribute("ref")!;
                    const currNode = nodesMap[id];
                    let edgeAddedThisIteration = false;

                    // Once another vertex is reached...
                    if (
                        prevNode !== null &&
                        startVertex !== null &&
                        currNode.isVertex
                    ) {
                        edgeAddedThisIteration = true;

                        // Add the last node in the edge now
                        edge.push(currNode);

                        // Create a new edge and add it to the graph
                        const mapEdge = new MapEdge(
                            edge,
                            colors[colorCount++ % colors.length],
                        );
                        const endVertex = mapGraph.getVertexByNodeId(id)!;
                        mapGraph.addEdge(startVertex, endVertex, mapEdge);

                        // Clear out the edge and set the new starting vertex
                        edge = [];
                        startVertex = endVertex;
                    }

                    // The end of streets should be vertices
                    if (!edgeAddedThisIteration && index + 1 == nds.length) {
                        currNode.setIsVertex(true);
                        const vertex = new MapVertex(nodesMap[id]);
                        mapGraph.addVertex(vertex);

                        // Add the last node in the edge now
                        edge.push(currNode);

                        // Create a new edge and add it to the graph
                        const mapEdge = new MapEdge(
                            edge,
                            colors[colorCount++ % colors.length],
                        );
                        const endVertex = mapGraph.getVertexByNodeId(id)!;
                        mapGraph.addEdge(startVertex!, endVertex, mapEdge);

                        // Clear out the edge and set the new starting vertex
                        edge = [];
                        startVertex = endVertex;
                    }

                    if (startVertex === null) {
                        currNode.setIsVertex(true); // The starts of streets should be vertices
                        const vertex = new MapVertex(nodesMap[id]);
                        mapGraph.addVertex(vertex);
                        startVertex = vertex;
                    }

                    edge.push(currNode);
                    prevNode = currNode;
                });
            });

            // mapGraph.drawVertices(context);
            mapGraph.drawEdges(context, undefined, 1);
        };
    }
</script>
